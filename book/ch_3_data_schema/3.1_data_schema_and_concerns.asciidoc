== Handling The App Data

The data layer covers a lot. That's why it's awesome we have so many good tools to work with. Regardless of the tools you choose, you do need to understand a bit about what's going on beneath the surface. When you start building your data schema, take your time and really write it out. The data schema drives everything for the app and any of its dependencies. Over time, it can almost be impossible to update the schema without breakinng everything. So you'll go through this step by step, like this:

- Make a diagram for data schema. This should include the tables, their columns and data types, and their relationships.
- Set up the database connection in the app. This example will use Prisma to connect to a https://www.postgresql.org/[PostgreSQL] database, but there are other popular tools like https://knexjs.org/[Knex] you can use.
- Write the data schema in the app. Take your diagram and translate it into code.
- Add seed data. This is to ensure that your database has the essential data it needs from the beginning. It's also a great tool for adding data for testing in different environments.
- Run migrations. After the connection is established and the schema and seed data and ready, you need to run a migration to get these changes to the database.
- Test the database with simple SQL queries. Check that the tables are creating, updating and storing data as expected. Double-check the relations between tables by looking at foreign keys.

These are the basic steps you need to take to build out your data layer. Some apps will have a more complex scenario than this, but you'll see a process similar to this across all projects. You already know what data is you're expecting based on your conversations with Product, so now it's time to make a good diagram for the dev team.

[NOTE]
====
We're not going to discuss non-relational databases in this book because relational databases are the most commonn to work with. Non-relational databases have specific use cases, but many apps are fine with a normal relational database.
====

=== Diagramming the data schema

A diagram is a great visual reference for developers and QA to understand what values to expect and why. It's a great tool to spark discussions between the front-end and back-end and document relations between data in a non-code way. Again, they don't have to be anything fancy. Something developers tend to get hung up on are little details in places that don't matter. As a senior dev, you have to be self-aware enough to notice when you start diving too deep on a task that doesn't need that much attention.

These tables, for example, can be just like the ones below. You could even make them in a Google Sheet or https://www.notion.so/[Notion] or any other tool. The important part is that it's in a format that everyone can understand.

+-------------+--------------+----------------------------+
|                     customer_data                       |
+-------------+--------------+----------------------------+
| id          | int(11)      | PRIMARY KEY AUTO_INCREMENT |
| height      | int(11)      |                            |
| width       | int(11)      |                            |
| comment     | varchar(255) |                            |
| compressed  | boolean      |                            |
| orientation | varchar(255) |                            |
| photoId     | int(11)      | FOREIGN KEY                |
+-------------+--------------+----------------------------+

+-------------+--------------+----------------------------+
|                     customer_data                       |
+-------------+--------------+----------------------------+
| id          | int(11)      | PRIMARY KEY AUTO_INCREMENT |
| height      | int(11)      |                            |
| width       | int(11)      |                            |
| comment     | varchar(255) |                            |
| compressed  | boolean      |                            |
| orientation | varchar(255) |                            |
| photoId     | int(11)      | FOREIGN KEY                |
+-------------+--------------+----------------------------+

+-------------+--------------+----------------------------+
|                     customer_data                       |
+-------------+--------------+----------------------------+
| id          | int(11)      | PRIMARY KEY AUTO_INCREMENT |
| height      | int(11)      |                            |
| width       | int(11)      |                            |
| comment     | varchar(255) |                            |
| compressed  | boolean      |                            |
| orientation | varchar(255) |                            |
| photoId     | int(11)      | FOREIGN KEY                |
+-------------+--------------+----------------------------+

Now that you have the data schema documented. You'll take this to the team and walk through what your thoughts are and ask for feedback. The front-end devs might have specific data format requests based on how they have to render elements. Other devs might bring up security considerations. By opening this up for everyone to think about, you end up with a stronger schema than if one person handled it alone. As a senior dev, you'll learn how to share your ideas first.

It can be an uncomfortable place to be for a while because it feels like everyone is heavily scrutinizing your code. They aren't. The only thing they're trying to do is pick it apart and that's what will help you and the team build better code. The more you present your code and thoughts to the team, the quicker you'll be able to improve things for everyone.

With the data schema diagramed and agreed upon by the front-end and back-end devs, you can start work on connecting the back-end to the database to create these tables. You'll be working with a Postgres instance locally, but this can also be hosted on a server in the cloud.

=== Setting up Postgres

You need to set up Postgres so you can get the connection information for your app. This will normally be handled by the team that manages the infrastructure for your production and non-production environments. You'll still need your own local instance to make sure the changes you and the team are making work as expected. You can download Postgres for free https://www.postgresql.org/download/[here]. Follow their documentation to get everything up and running. You can set a master password or a password on the database you create, or not. Since this is your own local instance, you don't have to worry about database security.

If you do choose to create a database password, make sure you remember it. You'll need it to connect your app to the database. You'll also need the database name, port number, and database username. This project will name the database, +dashboard+. Unless you chose something other than the default values, the other credentials will be the following:

- Database username: +postgres+
- Database port number: +5432+

The password depends on what you decided to do when you intially set up Postgres. If you installed via the linked download, then you can create your database in pgAdmin. It will look similar to this:

[[fig-2.2-1]]
.Dashboard database in local Postgres
image::images/fig-2.2-1.png["Dashboard database in local Postgres"]

When you're at this point, you're ready to start creating the tables you diagramed earlier. We're going to look at a couple of different approaches to create these tables: SQL statements and using an object-relational mapping (ORM) tool.

=== Basic SQL commands to know

Let's start with using SQL statements. As a senior full-stack developer, it's good to know some basic SQL commands. You don't have to get super in-depth with things like views and indexing, but knowing enough to do create-read-update-delete (CRUD) operations goes a long way. One way to get started is by writing the statement to create a new table. You can do that with the following SQL:

[source, sql]
----
CREATE TABLE accounts (
	user_id serial PRIMARY KEY,
	username VARCHAR ( 50 ) UNIQUE NOT NULL,
	password VARCHAR ( 50 ) NOT NULL,
	email VARCHAR ( 255 ) UNIQUE NOT NULL,
	created_on TIMESTAMP NOT NULL,
        last_login TIMESTAMP 
);
----

Now you have this new table and it's completely empty. For testing purposes, you can add new row entries like this:

[source, sql]
----
INSERT INTO COMPANY (ID,NAME,AGE,ADDRESS,SALARY,JOIN_DATE)
VALUES (4, 'Mark', 25, 'Rich-Mond ', 65000.00, '2007-12-13' ), (5, 'David', 27, 'Texas', 85000.00, '2007-12-13')
RETURNING id;
----

To check that your data is stored like you expect it to be, you can query the data like this:

[source, sql]
----
SELECT	* FROM links;
----

And to round things out, you may need to delete some data to clean up an example you've been working on. You can do that with something like this:

[source, sql]
----
DELETE FROM links
WHERE id = 7
RETURNING *;
----

If you can casually use commands like these, you have enough SQL knowledge to double-check values directly in the database. Of course you can dive deeper into SQL and database management, but you don't need to in order to be a good senior full-stack dev. With these little SQL commands in your background knowledge, let's move on to the real tool you'll likely be using for database operations from your app.

=== Deciding what ORM to use to work with the data

Aside from choosing the framework for your back-end, the ORM tool is one of the big choices you'll make for the lifetime of your project. It's not an easy task to switch to a different ORM tool once you've started building. Nest.js comes with https://github.com/typeorm/typeorm[TypeORM], https://sequelize.org/[Sequelize], and https://mongoosejs.com/docs/[Mongoose] built in if you don't have a preference. There are other commonly used ORM tools like https://knexjs.org/[Knex] and Prisma, which you'll be using.

All of these tools essentially do the same thing, but with a different flavor. The one you use will come down to the comfort level of the team and any limitations they may have. For this project, you've decided to go with Prisma because it's the tool everyone on the team has used before, the documentation is well maintained, and it's a tool used by a lot of tech teams across different projects in the industry. Reasons like these make it a strong candidate and that's why you and the team have selected it.

Now you'll need to install it as a dev dependency in your project with the following command:

[source, bash]
----
npm install prisma @prisma/client --save-dev
----

[NOTE]
====
As a senior dev, there are some finer details you need to be aware of, especially concerning dependencies. When you are adding a dependency to your project, make sure you understand what type of dependency it needs to be. There are 3 types of dependencies: dependencies, development (dev) dependencies, and peer dependencies. Regular dependencies are the packages your app needs to run correctly. Dev dependencies are the packages that you need to do development work, like interfacing with the database. You'll learn more about peer dependencies if you work on a project that needs to published as its own package.
====

With Prisma installed in your project, you need to set up some configs to connect the app to your Postgres database. Like any ORM, you have to initialize it in your project. With Prisma, you can run this command to do that:

[source, bash]
----
npx prisma init --datasource-provider postgresql

âœ” Your Prisma schema was created at prisma/schema.prisma
  You can now open it in your favorite editor.

warn You already have a .gitignore file. Don't forget to add `.env` in it to not commit any private information.

Next steps:
1. Set the DATABASE_URL in the .env file to point to your existing database. If your database has no tables yet, read https://pris.ly/d/getting-started
2. Run prisma db pull to turn your database schema into a Prisma schema.
3. Run prisma generate to generate the Prisma Client. You can then start querying your database.

More information in our documentation:
https://pris.ly/d/getting-started
----

[TIP]
====
Always read the console output after you run commands. They usually give you useful advice!
====

This will create the +prisma+ directory and a +.env+ file in your project. Add +.env+ to your +.gitignore+ first. Then inside the +prisma+ directory, you'll find the +schema.prisma+ and this is where you'll set up your database connection and the models for the app. The +.env+ file has a URL to your database and this is the connection string that will contain the database credentials. Update the value for +DATABASE_URL+ in the +.env+ file with your local credentials. It might look something like this:

[source, bash]
----
DATABASE_URL="postgresql://username:password@localhost:5432/dashboard"
----

You'll also need to add +.env+ to your +.gitignore+ file. That way you don't accidentally commit real credentials to your repo. Any values in your +.env+ should be handled in your CI/CD pipeline. Work with the DevOps team to get this in place depending on the infrastructure setup. Now you can move over to the +schema.prisma+ file and start writing your model. This is one of the biggest differences between the ORM tools. Prisma has its own flavor that you'll have to get used to and it's ok to refer to the docs often.

In your +schema.prisma+, you can start adding pieces of your model. Add the following code to the end of the file:

[source, javascript]
----
// schema.prisma

...

model User {
  id       Int       @id @default(autoincrement())
  email    String    @unique
  name     String
  products Product[]
}

model Product {
  id       Int    @id @default(autoincrement())
  name     String
  imageUrl String
  price    Float
  quantity Int
  User     User?  @relation(fields: [userId], references: [id])
  userId   Int?
}
----

Building models with Prisma is similar to writing objects or type definitions if you're familiar with TypeScript. These models use special Prisma syntax for the types, but they match closely to the common types you work with. The most important thing to note is how relationships are defined between tables. On the Product table, you see we have an associated user id. On the User table, we have an array of products. This is how Prisma defines relationships between tables and I highly encourage you to look through their docuementation to learn about building more complex relationships. For this app though, these few models will get you moving.

This completes the data schema for your app so far. Now it's time to get this schema onto the database with a migration.

=== Writing migrations

Migrations are the SQL queries statements by the ORM based on your schema definition. When you connect to the database to run a migration, you're essentially executing SQL statements. That's what makes ORM tools so useful. Instead of having to manually write the SQL for multiple tables, like you you did earlier, you can write the query in JavaScript and the ORM will translate it to SQL. That's why JavaScript developers use these tools so they don't have to learn all of the details of SQL and database quirks.

To run a migration with Prisma, you'll open your console and navigate to the root of the project and run this command:

[source, bash]
----
npx prisma migrate dev --name initialize_dashboard_db

Environment variables loaded from .env
Prisma schema loaded from prisma/schema.prisma
Datasource "db": PostgreSQL database "dashboard", schema "public" at "localhost:5432"

Applying migration `20230318132006_initialize_dashboard_db`

The following migration(s) have been created and applied from new schema changes:

migrations/
  â””â”€ 20230318132006_initialize_dashboard_db/
    â””â”€ migration.sql

Your database is now in sync with your schema.
----

Anytime you update your schema you'll need to make a new migration to update the database. Make sure to give it a descriptive name so you can quickly understand what happened in the database history. This is super helpful if you run into data issues on the back-end because it's easier to see what changes have been made and when. Every migration will automatically generate the timestamp at the beginning of the folder name in Prisma. The timestamp is important so the database knows what order to run the migrations.

Other tools will handle migrations a little differently. Knex, for example, lets you write migrations in pure SQL if you want and it generates migration files instead of folders. If you look in your project's +prisma+ directory, you should see a +migrations+ folder with an subfolder. This is where the generated SQL for your migration is. That's the beauty of an ORM. You can write in syntax you're familiar with and it will generate the SQL for you. Take a look at the +migration.sql+ file in the migration folder. You'll see something like this:

[source, sql]
----
-- CreateTable
CREATE TABLE "User" (
    "id" SERIAL NOT NULL,
    "email" TEXT NOT NULL,
    "name" TEXT NOT NULL,

    CONSTRAINT "User_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "Product" (
    "id" SERIAL NOT NULL,
    "name" TEXT NOT NULL,
    "imageUrl" TEXT NOT NULL,
    "price" DOUBLE PRECISION NOT NULL,
    "quantity" INTEGER NOT NULL,
    "userId" INTEGER,

    CONSTRAINT "Product_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE UNIQUE INDEX "User_email_key" ON "User"("email");

-- AddForeignKey
ALTER TABLE "Product" ADD CONSTRAINT "Product_userId_fkey" FOREIGN KEY ("userId") REFERENCES "User"("id") ON DELETE SET NULL ON UPDATE CASCADE;
----

This is just the initial set up migration for the database and you'll be adding more tables and columns and changing names as the app grows. When you run into issues with a migration, you can roll it back and you'll learn how to do that in the debugging section of this chapter. For now, you have what you need to add some seed data to the database so you can start working on the rest of the app.

=== Seeding the database

Since this is your local database, you'll eventually want some test data to play with. You can add that as part of the dev env setup or have it as part of the setup for the real database. To start, create a new +seed.ts+ file in the +prisma+ directory. This is where you'll use the Prisma Client to create some records. In your +seed.ts+ file, add the following code:

[source, javascript]
----
// seed.ts

const { PrismaClient } = require('@prisma/client');
const db = new PrismaClient();

async function main() {
  const data = [
    { name: 'alice', email: 'alice@example.com' },
    { name: 'mark', email: 'mark@example.com' },
    { name: 'jackie', email: 'jackie@example.com' },
    { name: 'bob', email: 'bob@example.com' },
  ];

  return Promise.all(
    data.map(async (user) => {
      const record = await db.user.create({
        data: { name: user.name, email: user.email },
      });
    }),
  );
}

main()
  .catch((e) => console.error(e))
  .finally(async () => {
    await db.$disconnect();
  });
----

This code allows you to connect to the database and insert these new rows into their respective tables. Then it disconnects from the database. In order to run this with Prisma, you need to add the +seed+ config to your +package.json+ like this:

[source, json]
----
...

"collectCoverageFrom": [
      "**/*.(t|j)s"
    ],
    "coverageDirectory": "../coverage",
    "testEnvironment": "node"
  },
  "prisma": {
    "seed": "ts-node prisma/seed.ts"
  }
}
----

This tells Prisma where to look for your seed file and how to execute it. With the configs and some data ready, you can run this command to actually insert the data into your Postrgres instance:

[source, bash]
----
npx prisma db seed

Environment variables loaded from .env
Running seed command `ts-node prisma/seed.ts` ..

ðŸŒ±  The seed command has been executed.
----

Now if you look in your Postgres tables, you should see the values you wrote in +seed.ts+. This should be everything you need for your data concerns right now. Just to double-check, here's a quick checklist you can go through when you think you're finished setting everything up:

- Does the schema match the designs and functionality explained in the behavioral doc?
- Have you had at least one other dev look at it?
- Does your schema give room for the app to grow?
- Is there a way to audit actions and the users who triggered them?
- Have you considered different user role levels for table operation access?
- Have you checked to make sure the schema works for all of the apps consuming data from this database?

There are a wide range of questions you can ask here, but to keep things moving forward at this stage, don't get too deep into the details. If you can answer these questions, explain the schema decisions to another dev, amd you can demo it to the Product team, you're good to go for now.

Take notes and make Jira tickets for any optimizations you see along the way. That way you can come back and actually work on the details because it's documented in a way that Product considers. You've decided that the schema is in a good place and the tickets regarding different endpoints can be unblocked.

This is when you'll start working on the API that different apps will interact with to get data from the database you just set up. Let's start working on some Nest.js files.